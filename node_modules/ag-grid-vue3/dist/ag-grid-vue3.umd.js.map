{"version":3,"sources":["webpack://ag-grid-vue3/webpack/universalModuleDefinition","webpack://ag-grid-vue3/webpack/bootstrap","webpack://ag-grid-vue3/external {\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"root\":\"Vue\"}","webpack://ag-grid-vue3/external \"agGrid\"","webpack://ag-grid-vue3/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://ag-grid-vue3/(webpack)/buildin/global.js","webpack://ag-grid-vue3/./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://ag-grid-vue3/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://ag-grid-vue3/./src/VueComponentFactory.ts","webpack://ag-grid-vue3/./src/VueFrameworkComponentWrapper.ts","webpack://ag-grid-vue3/./src/Utils.ts","webpack://ag-grid-vue3/./src/VueFrameworkOverrides.ts","webpack://ag-grid-vue3/./src/AgGridVue.ts","webpack://ag-grid-vue3/./node_modules/@vue/cli-service/lib/commands/build/entry-lib-no-default.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA,mD;;;;;;;ACAA,mD;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA,4BAA4B,KAAK,EAAE,iDAAiD,KAAK,SAAS;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc,GAAG,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gCAAgC;AAChC;AACA;AACA,gCAAgC;AAChC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,2BAA2B,IAAI;AAC/B;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,MAAqC;AACxD,MAAM,SAAiB;AACvB;AACA,mBAAmB,MAAqC,IAAI,SAAiB;AAC7E,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B,qBAAqB,qBAAqB;AAC1C;;AAEuzB;;;;;;;;;ACvlBvzB;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;ACnBA;;AAEA;AACA;AACA,MAAM,KAAuC,EAAE,yBAQ5C;;AAEH;AACA;AACA,IAAI,qBAAuB;AAC3B;AACA;;AAEA;AACe,sDAAI;;;;;;;;;ACrB+I;;AAElK;AACA,+BAA+B,IAAI;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAqC,GAAG,EAEjD;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAqC,GAAG,EAGjD;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA,uBAAuB,iBAAiB;AACxC,oCAAoC;AACpC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAqC,IAAI,SAAS;AAC9E,oCAAoC,MAAqC,IAAI,SAAiB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAqC;AAChE,cAAc,SAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAA+D,EAAE,EAEpE;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAO;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAO;AAC5B;AACA,wBAAwB,2CAAK;AAC7B;AACA;AACA;AACA,yBAAyB,kDAAY;AACrC;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAO;AAC5B;AACA,wBAAwB,2CAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAK;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAqC;AAC5D,UAAU,SAAoD;AAC9D;AACA;AACA;AACA,iBAAiB,KAAqC,GAAG,EAE5C;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC,GAAG,EAE5C;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAA2D,EAAE,EAEhE;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,6CAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS,qCAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAO;AACrC;AACA,iCAAiC,4CAAM;AACvC;AACA;AACA;AACA,uBAAuB,qCAAc;AACrC;AACA;AACA;AACA,YAAY,8CAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAY;AAChD;AACA,YAAY,8CAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAU;AACtB;AACA;AACA;AACA,iBAAiB,gCAAS,YAAY,iCAAU;AAChD;AACA;AACA;AACA,iBAAiB,6CAAO;AACxB;AACA;AACA;AACA;AACA,uBAAuB,6CAAO,YAAY,kDAAY;AACtD;AACA,cAAc,4CAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAQ;AACjB;AACA;AACA;AACA;AACA;AACA,wDAAwD,6CAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC,GAAG,EAE5C;AACT;AACA,KAAK;AACL;AACA,aAAa,KAAqC,GAAG,EAE5C;AACT;AACA;AACA;AACA,8CAA8C,4CAAM,GAAG;AACvD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,4CAAM,GAAG;AACvD;AACA,CAAC;;AAED;AACA;AACA,SAAS,0BAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0BAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0BAAG;AACZ;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,KAAqC,GAAG,EAEjD;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,KAAqC,GAAG,EAEjD;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAqC;AAC5D,UAAU,SAEmB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC,GAAG,EAG5C;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAAG;AACtB,SAAS;AACT;AACA;AACA,SAAS;AACT,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAAG;AACtB,SAAS;AACT;AACA;AACA,SAAS;AACT,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAAG;AACtB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,mBAAmB,0BAAG;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAAG;AACtB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,mBAAmB,0BAAG;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAS;AAC9B,iCAAiC,KAAK;AACtC,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAS;AACjC;AACA;AACA;AACA,QAAQ,iCAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAQ;AACjB,aAAa,KAAqC,GAAG,EAE5C;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iCAAU;AAClB;AACA;AACA;AACA;AACA,SAAS,iCAAU;AACnB;AACA;AACA,SAAS,gCAAS;AAClB;AACA;AACA;AACA,gCAAgC,iCAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yCAAG;AACP;AACA;AACA,8BAA8B,8CAAQ;AACtC,8BAA8B,8CAAQ;;AAEtC;AACA;AACA;AACA,aAAa,KAAqC,GAAG,EAM5C;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAqC,GAAG,EAO5C;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAAO;AACtB;AACA,MAAM,8BAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gCAAS,YAAY,iCAAU;AACpF;AACA,YAAY,gDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAqC,IAAI,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAA2D,EAAE,EAEhE;AACL,gBAAgB,6CAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAU;AACjC;AACA;AACA,kBAAkB,MAAqC;AACvD,cAAc,SAED;AACb,cAAc,kCAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAiE,EAAE,EAGtE;AACL;AACA;;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","file":"ag-grid-vue3.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue\"), require(\"agGrid\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([, \"agGrid\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ag-grid-vue3\"] = factory(require(\"vue\"), require(\"agGrid\"));\n\telse\n\t\troot[\"ag-grid-vue3\"] = factory(root[\"Vue\"], root[\"agGrid\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE__8bd4__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"fae3\");\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8bd4__;","/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\n    ? Object.freeze({})\n    : {};\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof global !== 'undefined'\n                            ? global\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var currentScript = window.document.currentScript\n  if (process.env.NEED_CURRENTSCRIPT_POLYFILL) {\n    var getCurrentScript = require('@soda/get-current-script')\n    currentScript = getCurrentScript()\n\n    // for backward compatibility, because previously we directly included the polyfill\n    if (!('currentScript' in document)) {\n      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })\n    }\n  }\n\n  var src = currentScript && currentScript.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/)\n  if (src) {\n    __webpack_public_path__ = src[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\nexport default null\n","import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n    console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this._active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    get active() {\n        return this._active;\n    }\n    run(fn) {\n        if (this._active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            warn(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this._active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].stop();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this._active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        warn(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nconst createDep = (effects) => {\n    const dep = new Set(effects);\n    dep.w = 0;\n    dep.n = 0;\n    return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].w |= trackOpBit; // set was tracked\n        }\n    }\n};\nconst finalizeDepMarkers = (effect) => {\n    const { deps } = effect;\n    if (deps.length) {\n        let ptr = 0;\n        for (let i = 0; i < deps.length; i++) {\n            const dep = deps[i];\n            if (wasTracked(dep) && !newTracked(dep)) {\n                dep.delete(effect);\n            }\n            else {\n                deps[ptr++] = dep;\n            }\n            // clear bits\n            dep.w &= ~trackOpBit;\n            dep.n &= ~trackOpBit;\n        }\n        deps.length = ptr;\n    }\n};\n\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\nclass ReactiveEffect {\n    constructor(fn, scheduler = null, scope) {\n        this.fn = fn;\n        this.scheduler = scheduler;\n        this.active = true;\n        this.deps = [];\n        this.parent = undefined;\n        recordEffectScope(this, scope);\n    }\n    run() {\n        if (!this.active) {\n            return this.fn();\n        }\n        let parent = activeEffect;\n        let lastShouldTrack = shouldTrack;\n        while (parent) {\n            if (parent === this) {\n                return;\n            }\n            parent = parent.parent;\n        }\n        try {\n            this.parent = activeEffect;\n            activeEffect = this;\n            shouldTrack = true;\n            trackOpBit = 1 << ++effectTrackDepth;\n            if (effectTrackDepth <= maxMarkerBits) {\n                initDepMarkers(this);\n            }\n            else {\n                cleanupEffect(this);\n            }\n            return this.fn();\n        }\n        finally {\n            if (effectTrackDepth <= maxMarkerBits) {\n                finalizeDepMarkers(this);\n            }\n            trackOpBit = 1 << --effectTrackDepth;\n            activeEffect = this.parent;\n            shouldTrack = lastShouldTrack;\n            this.parent = undefined;\n            if (this.deferStop) {\n                this.stop();\n            }\n        }\n    }\n    stop() {\n        // stopped while running itself - defer the cleanup\n        if (activeEffect === this) {\n            this.deferStop = true;\n        }\n        else if (this.active) {\n            cleanupEffect(this);\n            if (this.onStop) {\n                this.onStop();\n            }\n            this.active = false;\n        }\n    }\n}\nfunction cleanupEffect(effect) {\n    const { deps } = effect;\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect);\n        }\n        deps.length = 0;\n    }\n}\nfunction effect(fn, options) {\n    if (fn.effect) {\n        fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn);\n    if (options) {\n        extend(_effect, options);\n        if (options.scope)\n            recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n}\nfunction stop(runner) {\n    runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = createDep()));\n        }\n        const eventInfo = (process.env.NODE_ENV !== 'production')\n            ? { effect: activeEffect, target, type, key }\n            : undefined;\n        trackEffects(dep, eventInfo);\n    }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n    let shouldTrack = false;\n    if (effectTrackDepth <= maxMarkerBits) {\n        if (!newTracked(dep)) {\n            dep.n |= trackOpBit; // set newly tracked\n            shouldTrack = !wasTracked(dep);\n        }\n    }\n    else {\n        // Full cleanup mode.\n        shouldTrack = !dep.has(activeEffect);\n    }\n    if (shouldTrack) {\n        dep.add(activeEffect);\n        activeEffect.deps.push(dep);\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\n        }\n    }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        // never been tracked\n        return;\n    }\n    let deps = [];\n    if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n        // collection being cleared\n        // trigger all effects for target\n        deps = [...depsMap.values()];\n    }\n    else if (key === 'length' && isArray(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= newLength) {\n                deps.push(dep);\n            }\n        });\n    }\n    else {\n        // schedule runs for SET | ADD | DELETE\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n        // also run for iteration key on ADD | DELETE | Map.SET\n        switch (type) {\n            case \"add\" /* TriggerOpTypes.ADD */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                else if (isIntegerKey(key)) {\n                    // new index added to array -> length changes\n                    deps.push(depsMap.get('length'));\n                }\n                break;\n            case \"delete\" /* TriggerOpTypes.DELETE */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                break;\n            case \"set\" /* TriggerOpTypes.SET */:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                }\n                break;\n        }\n    }\n    const eventInfo = (process.env.NODE_ENV !== 'production')\n        ? { target, type, key, newValue, oldValue, oldTarget }\n        : undefined;\n    if (deps.length === 1) {\n        if (deps[0]) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                triggerEffects(deps[0], eventInfo);\n            }\n            else {\n                triggerEffects(deps[0]);\n            }\n        }\n    }\n    else {\n        const effects = [];\n        for (const dep of deps) {\n            if (dep) {\n                effects.push(...dep);\n            }\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(createDep(effects), eventInfo);\n        }\n        else {\n            triggerEffects(createDep(effects));\n        }\n    }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n    // spread into array for stabilization\n    const effects = isArray(dep) ? dep : [...dep];\n    for (const effect of effects) {\n        if (effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n    for (const effect of effects) {\n        if (!effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n        if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\n            effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\n        }\n        if (effect.scheduler) {\n            effect.scheduler();\n        }\n        else {\n            effect.run();\n        }\n    }\n}\nfunction getDepFromReactive(object, key) {\n    var _a;\n    return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n/*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => Symbol[key])\n    .filter(isSymbol));\nconst get$1 = /*#__PURE__*/ createGetter();\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this);\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n            }\n            // we run the method using the original args first (which may be reactive)\n            const res = arr[key](...args);\n            if (res === -1 || res === false) {\n                // if that didn't work, run it again using raw values.\n                return arr[key](...args.map(toRaw));\n            }\n            else {\n                return res;\n            }\n        };\n    });\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking();\n            const res = toRaw(this)[key].apply(this, args);\n            resetTracking();\n            return res;\n        };\n    });\n    return instrumentations;\n}\nfunction hasOwnProperty(key) {\n    const obj = toRaw(this);\n    track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n    return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n            return shallow;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ &&\n            receiver ===\n                (isReadonly\n                    ? shallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : shallow\n                        ? shallowReactiveMap\n                        : reactiveMap).get(target)) {\n            return target;\n        }\n        const targetIsArray = isArray(target);\n        if (!isReadonly) {\n            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n                return Reflect.get(arrayInstrumentations, key, receiver);\n            }\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n        const res = Reflect.get(target, key, receiver);\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n        if (!isReadonly) {\n            track(target, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isRef(res)) {\n            // ref unwrapping - skip unwrap for Array + integer key.\n            return targetIsArray && isIntegerKey(key) ? res : res.value;\n        }\n        if (isObject(res)) {\n            // Convert returned value into a proxy as well. we do the isObject check\n            // here to avoid invalid value warning. Also need to lazy access readonly\n            // and reactive here to avoid circular dependency.\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    };\n}\nconst set$1 = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n            return false;\n        }\n        if (!shallow) {\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n                return true;\n            }\n        }\n        const hadKey = isArray(target) && isIntegerKey(key)\n            ? Number(key) < target.length\n            : hasOwn(target, key);\n        const result = Reflect.set(target, key, value, receiver);\n        // don't trigger if target is something up in the prototype chain of original\n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n            }\n            else if (hasChanged(value, oldValue)) {\n                trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n            }\n        }\n        return result;\n    };\n}\nfunction deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction has$1(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    return result;\n}\nfunction ownKeys(target) {\n    track(target, \"iterate\" /* TrackOpTypes.ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n    get: get$1,\n    set: set$1,\n    deleteProperty,\n    has: has$1,\n    ownKeys\n};\nconst readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n});\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\n    // of the value\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n    }\n    const { has } = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n    }\n    else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n    }\n    else if (target !== rawTarget) {\n        // #3602 readonly(reactive(Map))\n        // ensure that the nested reactive `Map` can do tracking for itself\n        target.get(key);\n    }\n}\nfunction has(key, isReadonly = false) {\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n        }\n        track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n    }\n    return key === rawKey\n        ? target.has(key)\n        : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n    }\n    return this;\n}\nfunction set(key, value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n    }\n    else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n    }\n    return this;\n}\nfunction deleteEntry(key) {\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get ? get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    const result = target.delete(key);\n    if (hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = (process.env.NODE_ENV !== 'production')\n        ? isMap(target)\n            ? new Map(target)\n            : new Set(target)\n        : undefined;\n    // forward the operation before queueing reactions\n    const result = target.clear();\n    if (hadItems) {\n        trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n    }\n    return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n    return function forEach(callback, thisArg) {\n        const observed = this;\n        const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n        return target.forEach((value, key) => {\n            // important: make sure the callback is\n            // 1. invoked with the reactive map as `this` and 3rd arg\n            // 2. the value received should be a corresponding reactive/readonly.\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\n        });\n    };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n    return function (...args) {\n        const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const targetIsMap = isMap(rawTarget);\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\n        const isKeyOnly = method === 'keys' && targetIsMap;\n        const innerIterator = target[method](...args);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly &&\n            track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n        // return a wrapped iterator which returns observed versions of the\n        // values emitted from the real iterator\n        return {\n            // iterator protocol\n            next() {\n                const { value, done } = innerIterator.next();\n                return done\n                    ? { value, done }\n                    : {\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                        done\n                    };\n            },\n            // iterable protocol\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nfunction createReadonlyMethod(type) {\n    return function (...args) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n        }\n        return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n    };\n}\nfunction createInstrumentations() {\n    const mutableInstrumentations = {\n        get(key) {\n            return get(this, key);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations = {\n        get(key) {\n            return get(this, key, false, true);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, true)\n    };\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n    iteratorMethods.forEach(method => {\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n    });\n    return [\n        mutableInstrumentations,\n        readonlyInstrumentations,\n        shallowInstrumentations,\n        shallowReadonlyInstrumentations\n    ];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n    const instrumentations = shallow\n        ? isReadonly\n            ? shallowReadonlyInstrumentations\n            : shallowInstrumentations\n        : isReadonly\n            ? readonlyInstrumentations\n            : mutableInstrumentations;\n    return (target, key, receiver) => {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n            return target;\n        }\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\n            ? instrumentations\n            : target, key, receiver);\n    };\n}\nconst mutableCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n    const rawKey = toRaw(key);\n    if (rawKey !== key && has.call(target, rawKey)) {\n        const type = toRawType(target);\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n            `which can lead to inconsistencies. ` +\n            `Avoid differentiating between the raw and reactive versions ` +\n            `of an object and only use the reactive version if possible.`);\n    }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* TargetType.COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* TargetType.COLLECTION */;\n        default:\n            return 0 /* TargetType.INVALID */;\n    }\n}\nfunction getTargetType(value) {\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\n        ? 0 /* TargetType.INVALID */\n        : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if (!isObject(target)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // target is already a Proxy, return it.\n    // exception: calling readonly() on a reactive object\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n        return target;\n    }\n    // target already has corresponding Proxy\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // only specific value types can be observed.\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* TargetType.INVALID */) {\n        return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        if ((process.env.NODE_ENV !== 'production')) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n        else {\n            trackEffects(ref.dep || (ref.dep = createDep()));\n        }\n    }\n}\nfunction triggerRefValue(ref, newVal) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(dep, {\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value',\n                newValue: newVal\n            });\n        }\n        else {\n            triggerEffects(dep);\n        }\n    }\n}\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, newVal);\n        }\n    }\n}\nfunction triggerRef(ref) {\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key];\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value;\n            return true;\n        }\n        else {\n            return Reflect.set(target, key, value, receiver);\n        }\n    }\n};\nfunction proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs)\n        ? objectWithRefs\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n    constructor(factory) {\n        this.dep = undefined;\n        this.__v_isRef = true;\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n        this._get = get;\n        this._set = set;\n    }\n    get value() {\n        return this._get();\n    }\n    set value(newVal) {\n        this._set(newVal);\n    }\n}\nfunction customRef(factory) {\n    return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nclass ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n        this._object = _object;\n        this._key = _key;\n        this._defaultValue = _defaultValue;\n        this.__v_isRef = true;\n    }\n    get value() {\n        const val = this._object[this._key];\n        return val === undefined ? this._defaultValue : val;\n    }\n    set value(newVal) {\n        this._object[this._key] = newVal;\n    }\n    get dep() {\n        return getDepFromReactive(toRaw(this._object), this._key);\n    }\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    return isRef(val)\n        ? val\n        : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar _a$1;\nclass ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this._setter = _setter;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this[_a$1] = false;\n        this._dirty = true;\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true;\n                triggerRefValue(this);\n            }\n        });\n        this.effect.computed = this;\n        this.effect.active = this._cacheable = !isSSR;\n        this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n    }\n    get value() {\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        const self = toRaw(this);\n        trackRefValue(self);\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false;\n            self._value = self.effect.run();\n        }\n        return self._value;\n    }\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = (process.env.NODE_ENV !== 'production')\n            ? () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n            : NOOP;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    if ((process.env.NODE_ENV !== 'production') && debugOptions && !isSSR) {\n        cRef.effect.onTrack = debugOptions.onTrack;\n        cRef.effect.onTrigger = debugOptions.onTrigger;\n    }\n    return cRef;\n}\n\nvar _a;\nconst tick = /*#__PURE__*/ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n    queue.push(fn);\n    if (!queued) {\n        queued = true;\n        tick.then(flush);\n    }\n};\nconst flush = () => {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]();\n    }\n    queue.length = 0;\n    queued = false;\n};\nclass DeferredComputedRefImpl {\n    constructor(getter) {\n        this.dep = undefined;\n        this._dirty = true;\n        this.__v_isRef = true;\n        this[_a] = true;\n        let compareTarget;\n        let hasCompareTarget = false;\n        let scheduled = false;\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n            if (this.dep) {\n                if (computedTrigger) {\n                    compareTarget = this._value;\n                    hasCompareTarget = true;\n                }\n                else if (!scheduled) {\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n                    scheduled = true;\n                    hasCompareTarget = false;\n                    scheduler(() => {\n                        if (this.effect.active && this._get() !== valueToCompare) {\n                            triggerRefValue(this);\n                        }\n                        scheduled = false;\n                    });\n                }\n                // chained upstream computeds are notified synchronously to ensure\n                // value invalidation in case of sync access; normal effects are\n                // deferred to be triggered in scheduler.\n                for (const e of this.dep) {\n                    if (e.computed instanceof DeferredComputedRefImpl) {\n                        e.scheduler(true /* computedTrigger */);\n                    }\n                }\n            }\n            this._dirty = true;\n        });\n        this.effect.computed = this;\n    }\n    _get() {\n        if (this._dirty) {\n            this._dirty = false;\n            return (this._value = this.effect.run());\n        }\n        return this._value;\n    }\n    get value() {\n        trackRefValue(this);\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        return toRaw(this)._get();\n    }\n}\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n    return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n","import {createVNode, defineComponent, render} from 'vue';\n\nexport class VueComponentFactory {\n\n    private static getComponentDefinition(component: any, parent: any) {\n        let componentDefinition: any;\n\n        // when referencing components by name - ie: cellRenderer: 'MyComponent'\n        if (typeof component === 'string') {\n            // look up the definition in Vue\n            componentDefinition = this.searchForComponentInstance(parent, component);\n        } else {\n            componentDefinition = {extends: defineComponent({...component})}\n        }\n        if (!componentDefinition) {\n            console.error(`Could not find component with name of ${component}. Is it in Vue.components?`);\n        }\n\n        if (componentDefinition.extends) {\n            if (componentDefinition.extends.setup) {\n                componentDefinition.setup = componentDefinition.extends.setup;\n            }\n\n            componentDefinition.extends.props = this.addParamsToProps(componentDefinition.extends.props)\n        } else {\n            componentDefinition.props = this.addParamsToProps(componentDefinition.props)\n        }\n\n        return componentDefinition;\n    }\n\n    private static addParamsToProps(props: any) {\n        if (!props || (Array.isArray(props) && props.indexOf('params') === -1)) {\n            props = ['params', ...(props ? props : [])];\n        } else if (typeof props === 'object' && !props.params) {\n            /* tslint:disable:no-string-literal */\n            props['params'] = {\n                type: Object\n            };\n        }\n\n        return props;\n    }\n\n    public static createAndMountComponent(component: any, params: any, parent: any, provides: any) {\n        const componentDefinition = VueComponentFactory.getComponentDefinition(component, parent);\n        if (!componentDefinition) {\n            return;\n        }\n\n        const {vNode, destroy, el} = this.mount(componentDefinition, {params: Object.freeze(params)}, parent, provides || {})\n\n        // note that the component creation is synchronous so that componentInstance is set by this point\n        return {\n            componentInstance: vNode.component.proxy,\n            element: el,\n            destroy,\n        };\n    }\n\n    public static mount(component: any, props: any, parent: any, provides: any) {\n        let vNode: any = createVNode(component, props)\n\n        vNode.appContext = parent.$.appContext;\n        vNode.appContext.provides = {...provides, ...(vNode.appContext.provides ? vNode.appContext.provides : {}), ...(parent.$parent.$options.provide ? parent.$parent.$options.provide : {})};\n\n        let el: any = document.createElement('div')\n        render(vNode, el)\n\n        const destroy = () => {\n            if (el) {\n                render(null, el)\n            }\n\n            el = null;\n            vNode = null;\n        }\n\n        return {vNode, destroy, el}\n    }\n\n    public static searchForComponentInstance(parent: any,\n                                             component: any,\n                                             maxDepth = 10,\n                                             suppressError = false) {\n        let componentInstance: any = null;\n\n        let currentParent = parent.$parent;\n        let depth = 0;\n        while (!componentInstance &&\n        currentParent &&\n        currentParent.$options &&\n        (++depth < maxDepth)) {\n            const currentParentAsThis = currentParent as any;\n            componentInstance = currentParentAsThis.$options && currentParentAsThis.$options.components ? currentParentAsThis.$options.components![component as any] : null;\n            currentParent = currentParent.$parent;\n        }\n\n        // then search in globally registered components of app\n        if (!componentInstance) {\n            const components = parent.$.appContext.components\n            if (components && components[component]) {\n                componentInstance = components[component];\n            }\n        }\n\n        if (!componentInstance && !suppressError) {\n            console.error(`Could not find component with name of ${component}. Is it in Vue.components?`);\n            return null;\n        }\n        return componentInstance;\n    }\n}\n","import { BaseComponentWrapper, WrappableInterface } from 'ag-grid-community';\nimport { VueComponentFactory } from './VueComponentFactory';\n\ninterface VueWrappableInterface extends WrappableInterface {\n    overrideProcessing(methodName: string): boolean;\n\n    processMethod(methodName: string, args: IArguments): any;\n}\n\nexport class VueFrameworkComponentWrapper extends BaseComponentWrapper<WrappableInterface> {\n    private parent: any | null;\n\n    private static provides : any;\n\n    constructor(parent: any, provides?: any) {\n        super();\n\n        this.parent = parent;\n\n        // when using master detail things provides to the master (like urlql) will not be available to the child components\n        // we capture the parent provides here (the first one will be the parent) - and re-use this when creating child components in VueComponentFactory\n        if(!VueFrameworkComponentWrapper.provides) {\n            VueFrameworkComponentWrapper.provides = provides;\n        }\n    }\n\n    public createWrapper(component: any): WrappableInterface {\n        const that = this;\n\n        class DynamicComponent extends VueComponent<any, any> implements WrappableInterface {\n            public init(params: any): void {\n                super.init(params);\n            }\n\n            public hasMethod(name: string): boolean {\n                return wrapper.getFrameworkComponentInstance()[name] != null;\n            }\n\n            public callMethod(name: string, args: IArguments): any {\n                const componentInstance = this.getFrameworkComponentInstance();\n                const frameworkComponentInstance = wrapper.getFrameworkComponentInstance();\n                return frameworkComponentInstance[name].apply(componentInstance, args);\n            }\n\n            public addMethod(name: string, callback: () => any): void {\n                (wrapper as any)[name] = callback;\n            }\n\n            public overrideProcessing(methodName: string): boolean {\n                return that.parent!.autoParamsRefresh && methodName === 'refresh';\n            }\n\n            public processMethod(methodName: string, args: IArguments): any {\n                if (methodName === 'refresh') {\n                    this.getFrameworkComponentInstance().params = args[0];\n                }\n\n                if (this.hasMethod(methodName)) {\n                    return this.callMethod(methodName, args);\n                }\n\n                return methodName === 'refresh';\n            }\n\n            protected createComponent(params: any): any {\n                return that.createComponent(component, params);\n            }\n        }\n\n        const wrapper = new DynamicComponent();\n        return wrapper;\n    }\n\n    public createComponent<T>(component: any, params: any): any {\n        return VueComponentFactory.createAndMountComponent(component, params, this.parent!, VueFrameworkComponentWrapper.provides!);\n    }\n\n    protected createMethodProxy(wrapper: VueWrappableInterface, methodName: string, mandatory: boolean): () => any {\n        return function() {\n            if (wrapper.overrideProcessing(methodName)) {\n                return wrapper.processMethod(methodName, arguments);\n            }\n\n            if (wrapper.hasMethod(methodName)) {\n                return wrapper.callMethod(methodName, arguments);\n            }\n\n            if (mandatory) {\n                console.warn('AG Grid: Framework component is missing the method ' + methodName + '()');\n            }\n            return null;\n        };\n    }\n\n    protected destroy() {\n        this.parent = null;\n    }\n}\n\nabstract class VueComponent<P, T> {\n    private componentInstance: any;\n    private element!: HTMLElement;\n    private unmount: any;\n\n    public getGui(): HTMLElement {\n        return this.element;\n    }\n\n    public destroy(): void {\n        if (this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy === 'function') {\n            this.getFrameworkComponentInstance().destroy();\n        }\n        this.unmount();\n    }\n\n    public getFrameworkComponentInstance(): any {\n        return this.componentInstance;\n    }\n\n    protected init(params: P): void {\n        const {componentInstance, element, destroy: unmount} = this.createComponent(params);\n\n        this.componentInstance = componentInstance;\n        this.unmount = unmount;\n\n        // the element is the parent div we're forced to created when dynamically creating vnodes\n        // the first child is the user supplied component\n        this.element = element.firstElementChild;\n    }\n\n    protected abstract createComponent(params: P): any;\n}\n\n","import {ComponentUtil} from 'ag-grid-community';\n\nexport const kebabProperty = (property: string) => {\n    return property.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n};\n\nexport const kebabNameToAttrEventName = (kebabName: string) => {\n    // grid-ready for example would become onGrid-ready in Vue\n    return `on${kebabName.charAt(0).toUpperCase()}${kebabName.substring(1, kebabName.length)}`\n};\n\nexport interface Properties {\n    [propertyName: string]: any;\n}\n\nexport const getAgGridProperties = (): [Properties, Properties] => {\n    const props: Properties = {};\n\n    // for example, 'grid-ready' would become 'onGrid-ready': undefined\n    // without this emitting events results in a warning\n    // and adding 'grid-ready' (and variations of this to the emits option in AgGridVue doesn't help either)\n    const eventNameAsProps = ComponentUtil.PUBLIC_EVENTS.map((eventName: string) => kebabNameToAttrEventName(kebabProperty(eventName)));\n    eventNameAsProps.forEach((eventName: string) => props[eventName] = undefined)\n\n    const watch: Properties = {};\n\n    ComponentUtil.ALL_PROPERTIES\n        .filter((propertyName: string) => propertyName != 'gridOptions') // dealt with in AgGridVue itself\n        .forEach((propertyName: string) => {\n            props[propertyName] = {};\n\n            watch[propertyName] = {\n                handler(currentValue: any, previousValue: any) {\n                    this.processChanges(propertyName, currentValue, previousValue);\n                },\n                deep: propertyName !== 'popupParent' && propertyName !== 'context'\n            };\n        });\n\n    return [props, watch];\n};\n\n","import {VanillaFrameworkOverrides} from 'ag-grid-community';\nimport {VueComponentFactory} from './VueComponentFactory';\n\nexport class VueFrameworkOverrides extends VanillaFrameworkOverrides {\n    private readonly parent: any;\n\n    constructor(parent: any) {\n        super();\n\n        this.parent = parent;\n    }\n\n    /*\n     * vue components are specified in the \"components\" part of the vue component - as such we need a way to determine\n     * if a given component is within that context - this method provides this\n     * Note: This is only really used/necessary with cellRendererSelectors\n     */\n    public frameworkComponent(name: string, components?: any): any {\n        let result = !!VueComponentFactory.searchForComponentInstance(this.parent, name, 10, true) ? name : null;\n        if (!result && components && components[name]) {\n            const indirectName = components[name];\n            result = !!VueComponentFactory.searchForComponentInstance(this.parent, indirectName, 10, true) ? indirectName : null;\n        }\n        return result;\n    }\n\n    public isFrameworkComponent(comp: any): boolean {\n        return typeof comp === 'object';\n    }\n}\n","import {defineComponent, getCurrentInstance, h, PropType} from 'vue';\nimport {markRaw, toRaw} from '@vue/reactivity';\nimport { ComponentUtil, Grid, GridOptions, Module, IRowNode } from 'ag-grid-community';\n\nimport {VueFrameworkComponentWrapper} from './VueFrameworkComponentWrapper';\nimport { getAgGridProperties, Properties } from './Utils';\nimport {VueFrameworkOverrides} from './VueFrameworkOverrides';\n\nconst ROW_DATA_EVENTS = ['rowDataChanged', 'rowDataUpdated', 'cellValueChanged', 'rowValueChanged'];\nconst DATA_MODEL_ATTR_NAME = 'onUpdate:modelValue'; // emit name would be update:ModelValue\nconst DATA_MODEL_EMIT_NAME = 'update:modelValue';\n\nconst [props, watch] = getAgGridProperties();\n\nexport const AgGridVue = defineComponent({\n    render() {\n        return h('div')\n    },\n    props: {\n        gridOptions: {\n            type: Object as PropType<GridOptions>,\n            default: () => ({} as GridOptions),\n        },\n        autoParamsRefresh: {\n            type: Boolean,\n            default: () => false,\n        },\n        componentDependencies: {\n            type: Array as PropType<String[]>,\n            default: () => [],\n        },\n        plugins: [],\n        modules: {\n            type: Array as PropType<Module[]>,\n            default: () => [],\n        },\n        modelValue: {\n            type: Array,\n            default: undefined,\n            required: false\n        },\n        ...props\n    },\n    data() {\n        return {\n            gridCreated: false,\n            isDestroyed: false,\n            gridReadyFired: false,\n            emitRowModel: undefined as (() => void | null) | undefined\n        }\n    },\n    watch: {\n        modelValue: {\n            handler(currentValue: any, previousValue: any) {\n                this.processChanges('rowData', currentValue, previousValue);\n            },\n            deep: true\n        },\n        ...watch\n    },\n    methods: {\n        globalEventListener(eventType: string, event: any) {\n            if (this.isDestroyed) {\n                return;\n            }\n\n            if (eventType === 'gridReady') {\n                this.gridReadyFired = true;\n            }\n\n            this.updateModelIfUsed(eventType);\n        },\n        processChanges(propertyName: string, currentValue: any, previousValue: any) {\n            if (this.gridCreated) {\n                if (this.skipChange(propertyName, currentValue, previousValue)) {\n                    return;\n                }\n\n                const changes: Properties = {};\n                changes[propertyName] = {\n                    // decouple the row data - if we don't when the grid changes row data directly that'll trigger this component to react to rowData changes,\n                    // which can reset grid state (ie row selection)\n                    currentValue: propertyName === 'rowData' ? (Object.isFrozen(currentValue) ? currentValue : markRaw(toRaw(currentValue))) : currentValue,\n                    previousValue,\n                };\n                ComponentUtil.processOnChange(changes, this.gridOptions.api!);\n            }\n        },\n        checkForBindingConflicts() {\n            const thisAsAny = (this as any);\n            if ((thisAsAny.rowData || this.gridOptions.rowData) &&\n                thisAsAny.modelValue) {\n                console.warn('AG Grid: Using both rowData and v-model. rowData will be ignored.');\n            }\n        },\n        getRowData(): any[] {\n            const rowData: any[] = [];\n            this.gridOptions.api!.forEachNode((rowNode: IRowNode) => {\n                rowData.push(rowNode.data);\n            });\n            return rowData;\n        },\n        updateModelIfUsed(eventType: string) {\n            if (this.gridReadyFired &&\n                this.$attrs[DATA_MODEL_ATTR_NAME] &&\n                ROW_DATA_EVENTS.indexOf(eventType) !== -1) {\n\n                if (this.emitRowModel) {\n                    this.emitRowModel();\n                }\n            }\n        },\n        getRowDataBasedOnBindings() {\n            const thisAsAny = (this as any);\n\n            const rowData = thisAsAny.modelValue\n            return rowData ? rowData :\n                thisAsAny.rowData ? thisAsAny.rowData : thisAsAny.gridOptions.rowData;\n        },\n        getProvides() {\n            let instance = getCurrentInstance() as any;\n            let provides = {};\n\n            while (instance) {\n                if (instance && instance.provides) {\n                    provides = {...provides, ...instance.provides}\n                }\n\n                instance = instance.parent;\n            }\n\n            return provides;\n        },\n        /*\n        * Prevents an infinite loop when using v-model for the rowData\n        */\n        skipChange(propertyName: string, currentValue: any, previousValue: any) {\n            if (this.gridReadyFired &&\n                propertyName === 'rowData' &&\n                this.$attrs[DATA_MODEL_ATTR_NAME]) {\n                if (currentValue === previousValue) {\n                    return true;\n                }\n\n                if (currentValue && previousValue) {\n                    const currentRowData = currentValue as any[];\n                    const previousRowData = previousValue as any[];\n                    if (currentRowData.length === previousRowData.length) {\n                        for (let i = 0; i < currentRowData.length; i++) {\n                            if (currentRowData[i] !== previousRowData[i]) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n        debounce(func: () => void, delay: number) {\n            let timeout: number;\n            return () => {\n                const later = function () {\n                    func();\n                };\n                window.clearTimeout(timeout);\n                timeout = window.setTimeout(later, delay);\n            };\n        }\n    },\n    mounted() {\n        // we debounce the model update to prevent a flood of updates in the event there are many individual\n        // cell/row updates\n        this.emitRowModel = this.debounce(() => {\n            this.$emit(DATA_MODEL_EMIT_NAME, Object.freeze(this.getRowData()));\n        }, 20);\n\n\n        const provides = this.getProvides();\n        const frameworkComponentWrapper = new VueFrameworkComponentWrapper(this, provides);\n\n        // the gridOptions we pass to the grid don't need to be reactive (and shouldn't be - it'll cause issues\n        // with mergeDeep for example\n        const gridOptions = markRaw(ComponentUtil.copyAttributesToGridOptions(toRaw(this.gridOptions), this, true));\n\n        this.checkForBindingConflicts();\n\n        const rowData = this.getRowDataBasedOnBindings();\n        gridOptions.rowData = rowData ? (Object.isFrozen(rowData) ? rowData : markRaw(toRaw(rowData))) : rowData;\n\n        const gridParams = {\n            globalEventListener: this.globalEventListener.bind(this),\n            frameworkOverrides: new VueFrameworkOverrides(this),\n            providedBeanInstances: {\n                frameworkComponentWrapper,\n            },\n            modules: this.modules,\n        };\n\n        new Grid(this.$el as HTMLElement, gridOptions, gridParams);\n\n        this.gridCreated = true;\n    },\n    unmounted() {\n        if (this.gridCreated) {\n            if (this.gridOptions.api) {\n                this.gridOptions.api.destroy();\n            }\n            this.isDestroyed = true;\n        }\n    }\n});\n","import './setPublicPath'\nexport * from '~entry'\n"],"sourceRoot":""}